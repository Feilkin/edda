// the game engine would define this

trait Equipment {
	weight: (self) -> Number // name: argument list -> return value
	cost:   (self) -> Number
	name:   (self) -> String
}

trait Weapon: Equipment { // or trait Weapong requires Equipment, syntax is still open
	damage_type: (self) -> String // I don't think I need enums
	get_damage:  (self, RandomState) -> Number // returns damage proc with given random state
}

// then, in some game/mod file

// define a new type, with given fields
type Sword { weight: Number, cost: Number, name: String, damage: Range<Number, Number> };

// manual definition
implement Equipment for Sword {
	weight: (self) -> { self.weight }
	cost:   (self) -> { self.cost }
	name:   (self) -> { self.name }
}

implement Equipment for Sword with (method) -> { self[method] }; // idk, metaprogramming syntax is still WIP

implement Weapon for Sword {
	damage_type: (self) -> { "slash" }
	get_damage:  (self, rnd_state) -> { self.damage.min() + (self.damage.max() - self.damage.min()) * rnd_state.random() }
}

// now, make an instance of the Sword

let rare_sword = Sword { name: "rare super sword", weight: 5.3, cost: 1000, damage: 50 .. 100 };

// get damage

let damage_proc = rare_sword.get_damage( RandomState::new() );

// get weight from Equipment trait, because the type shadows the 'weight' field

(rare_sword as Equipment).weight(); // (something as Trait) would return the Trait implementation of something
rare_sword::Equipment.weight(); // alternative syntax to access the trait implementation, don't know which I like more
Sword::Equipment.weight(rare_sword); // using the type 'object', not sure if this makes sense